This will be the beginning of my studies for MIT 6.096.

It's high time I've dug deeper into a C based mid/high language - this repository will be for C++ dev and Git learning in parallel.

useful git commands:
    after initialising git with 'git init'
    or cloning existing git with 'git clone'

    all new files you create will be untracked. to track them so they will be added into the git going forward:
    'git add "file"'
        rerunning this command will push a new commit

    this is because git works on a three/four stage principle:
        untracked: files in the repository that haven't been tracked yet or otherwise are garbage to be removed
        unmodified: git retains a pointer to this version of the file
        modified: you've made changes to a file that will need to be pushed
        staged: git records a new version of the file and commits it to a snapshot
    
    file status with 'git status'

    sometimes we want to ignore garbage files like locally produced logs and what not
        by creating .gitignore file - this will initialise the repository with things you want to avoid committing
        good examples here: 'https://github.com/github/gitignore'

        you can use one root .gitignore for the whole repository or even nest further conditions in deeper subdirectories

    show what you've changed but not staged with 'git diff'
        for staged that will be committed: 'git diff --staged'

    commit file with 'git commit'
        can skip staging with 'git commit -a'
    
    removing files from tracked with 'git rm'
        if already in staging, must be force removed with 'git rm -f'
        add --cached if you forgot to ignore it

    file movement - if you want to rename a file
        $ git mv file_from file_to
        works like
        $ mv README.md README
        $ git rm README.md
        $ git add README

    view commit history with 'git log'
        -p or --patch shows patches
        -<n> shows most recent n patches
    
        --pretty formats the log differently. you can add a number of different outputs with stuff like :oneline
        --since and --until constrain the time period for logging displayed

    undoing mistakes - can be very dangerous in git, since things are typically overwritnen
        commit once, preserve forever (with exceptions)

        'git reset HEAD <file' unstages
        'git checkout -- <file>...' if you want to wipe away all progress since last commit

    remote repositories are stored elsewhere, on servers or other distributed networks
        'git remote' to show which remotes are configured
        'git remote add <shortname> <url>'
            shortname is the new reference by which URL can be called

        now you can 'git fetch <remote>' to update your local with everything new in the remote
            'git pull <remote>' fetches then merges a branch into yours

        'git push <remote> <branch>' to push updates to the remote
        ' git remote show<remote>' to inspect the 

        'git remote rename <old> <new>' to rename the remote

    tagging - versioning
        to show all extant tags 'git tag'
        annotated tags show all info - author, datestamp, email
            $ git tag -a v1.4 -m "my version 1.4"
            -m specifies message to be included with the tag
        lightweight tags are just the checksum
            $ git tag v1.4-lw

        tagging ex post facto
            $ git tag -a v1.2 9fceb02
            where the last block there is part of the checksum

        git push does not explicitly send tags as well.
            however, the process is identical to pushing branches
            'git push origin <tagname>'

        -d will delete a specified tag

    aliasing - shortening the referent by creating a much easier reference
        $ git config --global alias.br branch

branching - diverging from main line of development to work in a free experimental space
    exploration into taxonomy:
        each commit holds a reference to a tree, as well as author name, etc
        each tree holds references to underlying blobs.
        these blobs are the files that you're working on. 

        subsequent commits will hold pointers to previous commits - this is how git tracks the changing snapshots

        the branch moves the pointer elsewhere. the commit you're currently looking at is marked by the HEAD (like of a tape)

    create new branch with 'git branch <name>'
    see where you're at with 'git log'
        add --all to show all branches
    to switch to an extent branch, 'git checkout <name>'
        add -b to create a branch and switch to it

    best practice is to clean your working area before switching
        i think i lost the previous version of these notes by not doing this...

        'git merge' applies the changes of a branch into a previous one
        you can do this to move the master branch forward
        if there are no conflicts, this is known as a fast forward, because the trajectory of your commits is a straight line.
        however, if you have another branch that you were working on for something else, merging with this new master means you have some changes not represented in the test branch
        you also now have a hotfix branch that points at the same place your master branch points, so you must delete the temp hotfix branch
        -d to delete a branch

        once you are ready to merge your older project, git works to combine snapshots from different periods of development
    
    merge conflicts
        if your fix involved changes in the same part of the same file for two branches when you try to merge them, you get conflicts
        git will give a separated comparison of what the conflict is within the same file
            to resolve, choose one of the options or merge them manually
            then restage the file to resolve the issue
        'git mergetool' offers a visual way to compare the changes

    branch management
        'git branch --merged' or '--no-merged' filters 'git branch' list to items that have been merged into the one you're currently on
    
    branching workflows
        merging branches into others multiple times thorughout development cycle is relatively straightforward under git
        for example, if your master branch is a dedicated stable environment,
            new changes can be branched off then merged back in to the master as needed.
            ideally you would want to have a series of branches for work of varying stability
        check out the images on page 81 and 82 for a good representation
    
    remote-tracking references
        these are pointers to the remote repository, which may or may not be at a different stage of development than your local environment
        
    remote branches
        git fetch command will fetch all the changes on the server that you don’t have yet but will not  modify  your  working  directory  at  all.
        git pull  will  look  up  what  server  and  branch  your  current  branch  is  tracking,  fetchfrom that server and then try to merge in that remote branch
            you must be tracking some remote branch

    rebasing
         take all thechanges that were committed on one branch and replay them on a different branch
         This operation works by going to the common ancestor of the two branches (the one you’re on andthe one you’re rebasing onto), 
         getting the diff introduced by each commit of the branch you’re on,saving those diffs to temporary files, 
         resetting the current branch to the same commit as the branchyou are rebasing onto, and finally applying each change in turn

        this is done for cleaner history as there will no longer be an offshoot branch - the commit log will be a line

        Do  not  rebase  commits  that  exist  outside  your  repository  and  that  people  may  have  based work on***